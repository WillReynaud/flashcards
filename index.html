<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cartes Chinoises - Audio Local</title>
    <style>
        html, body {
            margin: 0; padding: 0; height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: white;
            font-family: Arial, sans-serif;
            overflow-x: visible;
        }
        body {
            flex-direction: column;
        }
        .container {
            position: relative;
            width: 400px;
            height: 400px;
            user-select: none;
            touch-action: none; /* Empêche le défilement de la page lors du swipe */
        }
        .card {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            background: white;
            border: 2px solid black;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 5rem;
            z-index: 1;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transition: transform 0.3s ease-out, opacity 0.3s ease-out; /* Ajout des transitions */
        }
        .card.next {
            transform: scale(0.95);
            opacity: 0.3;
            z-index: 0;
        }
        /* Styles pour le swipe */
        .card.swiping {
            transition: none; /* Pas de transition pendant le swipe */
        }
        .card.swipe-right {
            transform: translateX(500px) rotate(15deg);
            opacity: 0;
        }
        .card.swipe-left {
            transform: translateX(-500px) rotate(-15deg);
            opacity: 0;
        }

        .audio-zone {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 60px;
            height: 60px;
            background: lightgray;
            border-radius: 50%;
            z-index: 2;
            cursor: pointer;
        }
        .buttons {
            margin-top: 30px;
            display: flex;
            gap: 40px;
        }
        button {
            width: 60px;
            height: 60px;
            font-size: 2rem;
            border-radius: 50%;
            border: 2px solid black;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: background-color 0.2s ease;
        }
        button:hover {
            background-color: #f0f0f0;
        }
        button#btnRight:hover {
            background-color: #d4edda; /* Vert clair */
        }
        button#btnWrong:hover {
            background-color: #f8d7da; /* Rouge clair */
        }
    </style>
</head>
<body>

    <div class="container" id="container">
        <div class="card current" id="cardCurrent">...</div>
        <div class="card next" id="cardNext">...</div>
        <div class="audio-zone" id="audioZone" title="Jouer l’audio"></div>
    </div>

    <div class="buttons">
        <button id="btnWrong" title="Je ne connais pas">✗</button>
        <button id="btnRight" title="Je connais">✓</button>
    </div>

    <script>
        const SHEET_CSV_URL = "https://docs.google.com/sheets/d/e/2PACX-1vQLhJumynOVacZQyjTJdfb2E03VOHW3FdlwYszFGHJcrOVWaihv-mrXDc3oegjTdFpJTobI1jN1nNpN/pub?gid=0&single=true&output=csv";

        let cards = [];
        let currentIndex = 0;
        let displayState = 0; // 0: character, 1: pinyin, 2: translation

        const cardCurrent = document.getElementById("cardCurrent");
        const cardNext = document.getElementById("cardNext");
        const btnRight = document.getElementById("btnRight");
        const btnWrong = document.getElementById("btnWrong");
        const audioZone = document.getElementById("audioZone");
        const container = document.getElementById("container"); // Ajouté pour le swipe

        let audio = new Audio();

        // Variables pour le swipe
        let isSwiping = false;
        let startX = 0;
        let currentX = 0;

        // --- Fonctions de gestion des cartes et données ---

        function parseCSV(text) {
            const lines = text.trim().split("\n");
            // Filtrer les lignes vides ou les en-têtes si nécessaire
            return lines.filter(line => line.trim() !== '' && !line.startsWith('character,pinyin,translation')).map(line => {
                const [character, pinyin, translation] = line.split(",");
                return {
                    character: character ? character.trim() : '',
                    pinyin: pinyin ? pinyin.trim() : '',
                    translation: translation ? translation.trim() : '',
                    familiarity: 0
                };
            });
        }

        function displayCardContent(index, element, state) {
            if (cards.length === 0) {
                element.textContent = "Aucune carte";
                return;
            }
            const card = cards[index];
            if (!card) { // Gérer le cas où l'index est invalide
                element.textContent = "Carte introuvable";
                return;
            }

            if (state === 0) {
                element.textContent = card.character;
            } else if (state === 1) {
                element.textContent = card.pinyin;
            } else { // state === 2
                element.textContent = card.translation;
            }
        }

        function refreshCardsDisplay() {
            displayState = 0; // Réinitialise l'affichage au caractère principal
            displayCardContent(currentIndex, cardCurrent, displayState);
            // La carte suivante n'affiche pas son contenu complet initialement
            cardNext.textContent = "...";
            // Réinitialise les styles de la carte actuelle
            cardCurrent.style.transform = 'translate(0px) rotate(0deg)';
            cardCurrent.style.opacity = '1';
            cardCurrent.classList.remove('swiping', 'swipe-right', 'swipe-left');

            // Met à jour la carte "next" (légèrement en arrière-plan)
            // Trouve l'index de la prochaine carte à afficher, pas forcément le suivant direct
            const nextCardIndex = weightedRandomIndex(cards); // Pourrait être le même que currentIndex si les poids sont très élevés
            displayCardContent(nextCardIndex, cardNext, 0); // Affiche le caractère de la prochaine carte
        }

        function weightedRandomIndex(cards) {
            if (cards.length === 0) return 0;
            const weights = cards.map(c => 6 - (c.familiarity || 0)); // Plus la familiarité est faible, plus le poids est élevé
            const total = weights.reduce((a, b) => a + b, 0);
            let r = Math.random() * total;
            for (let i = 0; i < cards.length; i++) {
                if (r < weights[i]) return i;
                r -= weights[i];
            }
            return 0; // Fallback
        }

        function advanceCard(known) {
            if (cards.length === 0) return;

            // Met à jour la familiarité de la carte actuelle
            if (known) {
                cards[currentIndex].familiarity = Math.min(cards[currentIndex].familiarity + 1, 5);
            } else {
                cards[currentIndex].familiarity = Math.max(cards[currentIndex].familiarity - 1, 0);
            }

            // Sélectionne la nouvelle carte
            currentIndex = weightedRandomIndex(cards);
            refreshCardsDisplay(); // Met à jour l'affichage
        }

        // --- Fonctions audio ---

        function playAudio() {
            console.log("--- playAudio() appelée ---");
            if (cards.length === 0 || !cards[currentIndex] || !cards[currentIndex].character) {
                console.log("Pas de cartes chargées ou caractère non défini, impossible de jouer l'audio.");
                alert("Pas de carte ou de caractère défini pour l'audio.");
                return;
            }
            const character = cards[currentIndex].character;
            const audioUrl = "audios/" + encodeURIComponent(character) + ".mp3"; // Encode le caractère pour l'URL
            console.log("URL audio générée :", audioUrl);

            audio.src = audioUrl;
            audio.load(); // Charge la nouvelle source
            audio.play().catch(err => {
                console.error("Erreur lors de la lecture de l'audio pour : " + character + " (URL: " + audioUrl + ")", err);
                // Alert plus informative pour l'utilisateur
                alert(`Impossible de jouer l'audio pour "${character}". Vérifiez si le fichier "${character}.mp3" existe dans le dossier 'audios' et si son nom correspond.`);
            });
        }

        // --- Fonctions de swipe ---

        function startSwipe(e) {
            isSwiping = true;
            // Stocke la position de départ (pour souris ou toucher)
            startX = (e.touches ? e.touches[0].clientX : e.clientX);
            cardCurrent.classList.add('swiping'); // Pour désactiver la transition CSS pendant le swipe
        }

        function duringSwipe(e) {
            if (!isSwiping) return;

            // Calcule la position actuelle et le delta
            currentX = (e.touches ? e.touches[0].clientX : e.clientX);
            const deltaX = currentX - startX;

            // Applique la transformation à la carte actuelle
            cardCurrent.style.transform = `translateX(${deltaX}px) rotate(${deltaX / 20}deg)`; // Fait tourner la carte un peu
            cardCurrent.style.opacity = 1 - Math.abs(deltaX) / (container.offsetWidth * 0.8); // Réduit l'opacité

            // Empêche le défilement de la page sur mobile
            e.preventDefault();
        }

        function endSwipe(e) {
            if (!isSwiping) return;
            isSwiping = false;

            const deltaX = currentX - startX;
            const threshold = container.offsetWidth / 4; // Seuil pour considérer un swipe valide (ex: 25% de la largeur du conteneur)

            cardCurrent.classList.remove('swiping'); // Réactive la transition CSS

            if (deltaX > threshold) {
                // Swipe vers la droite (connu)
                cardCurrent.classList.add('swipe-right');
                setTimeout(() => advanceCard(true), 300); // Avance après l'animation de sortie
            } else if (deltaX < -threshold) {
                // Swipe vers la gauche (non connu)
                cardCurrent.classList.add('swipe-left');
                setTimeout(() => advanceCard(false), 300); // Avance après l'animation de sortie
            } else {
                // Pas assez glissé, retourne la carte à sa position initiale
                cardCurrent.style.transform = 'translate(0px) rotate(0deg)';
                cardCurrent.style.opacity = '1';
            }
        }

        // --- Écouteurs d'événements ---

        audioZone.addEventListener("click", playAudio);

        // Au clic sur la carte, affiche l'information suivante
        cardCurrent.addEventListener("click", () => {
            displayState = (displayState + 1) % 3;
            displayCardContent(currentIndex, cardCurrent, displayState);
        });

        // Boutons de navigation
        btnRight.addEventListener("click", () => advanceCard(true));
        btnWrong.addEventListener("click", () => advanceCard(false));

        // Événements pour le swipe (souris)
        cardCurrent.addEventListener("mousedown", startSwipe);
        window.addEventListener("mousemove", duringSwipe); // Écoute sur la fenêtre pour ne pas perdre l'événement si la souris sort de la carte
        window.addEventListener("mouseup", endSwipe);

        // Événements pour le swipe (toucher sur mobile)
        cardCurrent.addEventListener("touchstart", startSwipe);
        window.addEventListener("touchmove", duringSwipe);
        window.addEventListener("touchend", endSwipe);


        // --- Initialisation ---

        fetch(SHEET_CSV_URL)
            .then(r => {
                if (!r.ok) {
                    throw new Error(`Erreur HTTP: ${r.status}`);
                }
                return r.text();
            })
            .then(text => {
                cards = parseCSV(text);
                if (cards.length > 0) {
                    currentIndex = weightedRandomIndex(cards);
                    refreshCardsDisplay();
                    console.log("Cartes chargées avec succès ! Première carte affichée :", cards[currentIndex]);
                } else {
                    cardCurrent.textContent = "Aucune carte trouvée dans le CSV.";
                    console.warn("Le fichier CSV est vide ou n'a pas pu être parsé.");
                }
            })
            .catch(err => {
                cardCurrent.textContent = "Erreur chargement données CSV";
                console.error("Erreur de chargement du CSV ou de parsing :", err);
            });
    </script>

</body>
</html>